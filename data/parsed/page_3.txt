5.1 Immortalization
The free-threaded build of the 3.13 release makes some objects immortal. Immortal objects are not deallocated and
have reference counts that are never modified. This is done to avoid reference count contention that would prevent
efficient multi-threaded scaling.
An object will be made immortal when a new thread is started for the first time after the main thread is running. The
following objects are immortalized:
• function objects declared at the module level
• method descriptors
• code objects
• module objects and their dictionaries
• classes (type objects)
Because immortal objects are never deallocated, applications that create many objects of these types may see in-
creased memory usage. This is expected to be addressed in the 3.14 release.
Additionally, numeric and string literals in the code as well as strings returned by sys.intern() are also immor-
talized. This behavior is expected to remain in the 3.14 free-threaded build.
5.2 Frame objects
It is not safe to access frame objects from other threads and doing so may cause your program to crash . This means
that sys._current_frames() is generally not safe to use in a free-threaded build. Functions like inspect.
currentframe() and sys._getframe() are generally safe as long as the resulting frame object is not passed to
another thread.
5.3 Iterators
Sharing the same iterator object between multiple threads is generally not safe and threads may see duplicate or
missing elements when iterating or crash the interpreter.
5.4 Single-threaded performance
The free-threaded build has additional overhead when executing Python code compared to the default GIL-enabled
build. In 3.13, this overhead is about 40% on the pyperformance suite. Programs that spend most of their time in C
extensions or I/O will see less of an impact. The largest impact is because the specializing adaptive interpreter (PEP
659) is disabled in the free-threaded build. We expect to re-enable it in a thread-safe way in the 3.14 release. This
overhead is expected to be reduced in upcoming Python release. We are aiming for an overhead of 10% or less on
the pyperformance suite compared to the default GIL-enabled build.
3
